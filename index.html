<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ふたり用 ToDo リスト</title>

  <!-- PWA manifest（ホーム画面追加でアプリ風） -->
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#111111">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ふたりToDo">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">

  <style>
    :root { color-scheme: dark light; }

    /* 横幅固定 & 横スワイプ無効化 */
    html, body {
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
      overscroll-behavior-x: none;
    }
    body{
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:#111;
      color:#eee;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      touch-action: pan-y;
    }

    header{
      padding:.8rem 1rem;
      background:#222;
      display:flex;
      align-items:center;
      justify-content:space-between;
      box-shadow:0 2px 4px rgba(0,0,0,.4);
    }
    header h1{ font-size:1.1rem; margin:0; }

    main{
      flex:1;
      width:100%;
      max-width:100%;
      margin:0 auto;
      padding:1rem;
      box-sizing:border-box;
    }
    #status{
      font-size:.8rem;
      opacity:.8;
      margin:.2rem 0 .8rem;
    }

    /* 名前選択ボックス */
    .name-box{
      display:flex;
      gap:.5rem;
      align-items:center;
      background:#181818;
      border:1px solid #262626;
      border-radius:.8rem;
      padding:.6rem .7rem;
      margin-bottom:.8rem;
    }
    .name-box .label{
      font-size:.85rem;
      opacity:.85;
      white-space:nowrap;
    }
    .name-choices{
      display:flex;
      gap:.5rem;
      flex:1;
      justify-content:flex-end;
    }
    .name-btn{
      padding:.5rem .8rem;
      border-radius:999px;
      border:none;
      background:#10b981;
      color:#fff;
      font-size:.85rem;
      font-weight:700;
      cursor:pointer;
      white-space:nowrap;
    }
    .name-hint{
      font-size:.75rem;
      opacity:.7;
      margin:-.3rem 0 .7rem .2rem;
    }

    form{
      display:flex;
      gap:.5rem;
      margin-bottom:1rem;
    }
    input[type="text"]{
      flex:1;
      padding:.6rem .8rem;
      border-radius:999px;
      border:1px solid #444;
      background:#181818;
      color:#eee;
      font-size:.95rem;
      box-sizing:border-box;
    }
    input[type="text"]::placeholder{ color:#777; }

    button{
      padding:.6rem .9rem;
      border-radius:999px;
      border:none;
      background:#3b82f6;
      color:#fff;
      font-size:.9rem;
      font-weight:600;
      cursor:pointer;
      white-space:nowrap;
    }
    button:active{
      transform:translateY(1px);
      filter:brightness(.9);
    }

    ul{
      list-style:none;
      padding:0;
      margin:0;
      display:flex;
      flex-direction:column;
      gap:.4rem;
      width:100%;
      box-sizing:border-box;
    }

    .todo-item{
      display:flex;
      align-items:center;
      gap:.5rem;
      padding:.45rem .6rem;
      border-radius:.6rem;
      background:#181818;
      border:1px solid #262626;
      width:100%;
      box-sizing:border-box;
      touch-action: pan-y;
    }
    .todo-item .text{
      flex:1;
      min-width:0;
      font-size:.9rem;
      word-break:break-all;
      display:flex;
      align-items:center;
      gap:.5rem;
    }
    .todo-item .text.done{
      text-decoration:line-through;
      opacity:.6;
    }
    .author{
      font-size:.72rem;
      opacity:.75;
      padding:.15rem .4rem;
      border-radius:999px;
      background:#0b0b0b;
      border:1px solid #333;
      white-space:nowrap;
    }
    .todo-item button{
      padding:.3rem .6rem;
      font-size:.75rem;
      background:#dc2626;
    }
    .todo-item input[type="checkbox"]{
      width:1rem; height:1rem;
    }

    /* Sortableの見た目 */
    .todo-item.sortable-ghost{ opacity:.4; }

    @media (min-width:768px){
      header h1{ font-size:1.2rem; }
      main{ padding-top:1.2rem; }
    }
  </style>
</head>
<body>
  <header>
    <h1>ふたり用 ToDo リスト</h1>
  </header>

  <main>
    <p id="status">Firebase に接続しています...</p>

    <!-- 名前選択（端末ごとに一度だけ） -->
    <div id="nameBox" class="name-box" style="display:none;">
      <div class="label">あなたは？</div>
      <div class="name-choices">
        <button class="name-btn" data-name="まさぴ">まさぴ</button>
        <button class="name-btn" data-name="ゆなぴ">ゆなぴ</button>
      </div>
    </div>
    <p id="nameHint" class="name-hint" style="display:none;">
      ※この端末から追加したToDoに名前が付きます
    </p>

    <form id="todo-form">
      <input id="todo-input" type="text" placeholder="やることを入力して Enter / 追加"
             autocomplete="off" required />
      <button type="submit">追加</button>
    </form>

    <ul id="todo-list"></ul>
  </main>

  <!-- SortableJS（即ドラッグで並び替え） -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>

  <!-- Firebase / App -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js';
    import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js';
    import {
      getFirestore, collection, addDoc, serverTimestamp,
      query, orderBy, onSnapshot,
      doc, updateDoc, deleteDoc,
      setDoc, getDoc, writeBatch
    } from 'https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js';

    // Firebase 設定（todo-f9789）
    const firebaseConfig = {
      apiKey: "AIzaSyCy6HHiGMsaXMCVkftoIlZIyJdp3YM7DsI",
      authDomain: "todo-f9789.firebaseapp.com",
      projectId: "todo-f9789",
      storageBucket: "todo-f9789.firebasestorage.app",
      messagingSenderId: "104760372026",
      appId: "1:104760372026:web:49268331b63b0189f57e03",
      measurementId: "G-PFHKZWT093"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const todosCol = collection(db, 'todos');

    const statusEl = document.getElementById('status');
    const form = document.getElementById('todo-form');
    const input = document.getElementById('todo-input');
    const list = document.getElementById('todo-list');

    const nameBox = document.getElementById('nameBox');
    const nameHint = document.getElementById('nameHint');
    const nameButtons = Array.from(nameBox.querySelectorAll('.name-btn'));

    const NAME_KEY = "todoDisplayName";
    let displayName = localStorage.getItem(NAME_KEY) || "";
    let currentUser = null;
    let sortable = null;
    let isSorting = false; // 並び替え中ガード
    let latestTodos = [];  // 次のorder計算用に保持

    function lockTodoUI(lock){
      input.disabled = lock;
      form.querySelector('button[type="submit"]').disabled = lock;
    }

    function pickNameUI(uid){
      nameBox.style.display = "flex";
      nameHint.style.display = "block";
      lockTodoUI(true);

      nameButtons.forEach(btn => {
        btn.onclick = async () => {
          const v = btn.dataset.name;
          displayName = v;
          localStorage.setItem(NAME_KEY, displayName);

          await setDoc(doc(db, "users", uid), {
            name: displayName,
            updatedAt: serverTimestamp()
          }, { merge: true });

          nameBox.style.display = "none";
          nameHint.style.display = "none";
          statusEl.textContent = `接続中: ${displayName}`;
          lockTodoUI(false);
        };
      });
    }

    async function ensureDisplayName(uid){
      // localStorageに名前があればそれを使う
      if (displayName && displayName.trim()){
        statusEl.textContent = `接続中: ${displayName}`;
        lockTodoUI(false);
        await setDoc(doc(db, "users", uid), {
          name: displayName.trim(),
          updatedAt: serverTimestamp()
        }, { merge: true });
        return;
      }

      // Firestore users/{uid} に名前があれば拾う（同じ端末復帰用）
      try{
        const uref = doc(db, "users", uid);
        const usnap = await getDoc(uref);
        if (usnap.exists() && usnap.data().name){
          displayName = usnap.data().name;
          localStorage.setItem(NAME_KEY, displayName);
          statusEl.textContent = `接続中: ${displayName}`;
          lockTodoUI(false);
          return;
        }
      }catch(e){
        console.warn("users read failed:", e);
      }

      // 無ければ選択UI
      pickNameUI(uid);
    }

    function nextOrderFor(doneTo){
      const group = latestTodos.filter(t => t.done === doneTo);
      const max = group.length ? Math.max(...group.map(t => t.order ?? 0)) : -1;
      return max + 1;
    }

    async function setDoneWithOrder(t, doneTo){
      const newOrder = nextOrderFor(doneTo);
      await updateDoc(doc(todosCol, t.id), { done: doneTo, order: newOrder });
    }

    // 匿名ログイン
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        statusEl.textContent = '匿名ログイン中...';
        lockTodoUI(true);
        try {
          await signInAnonymously(auth);
        } catch (e) {
          console.error(e);
          statusEl.textContent = 'ログインエラー: ' + e.message;
          return;
        }
        return;
      }

      currentUser = user;
      await ensureDisplayName(user.uid);

      // todos リアルタイム購読（createdAtで取得 → 未完了→完了の順で表示）
      const q = query(todosCol, orderBy('createdAt'));
      onSnapshot(q, async (snapshot) => {

        // ① 配列化
        const todos = snapshot.docs.map((d, i) => {
          const data = d.data();
          return {
            id: d.id,
            text: data.text || "",
            done: !!data.done,
            authorName: data.authorName || "unknown",
            order: (typeof data.order === "number") ? data.order : null,
            _fallbackIndex: i
          };
        });

        // ② orderが無い旧データがあれば初回だけ採番
        const needBackfill = todos.some(t => t.order === null);
        if (needBackfill) {
          const batch = writeBatch(db);
          todos.forEach((t, idx) => {
            if (t.order === null) {
              batch.update(doc(todosCol, t.id), { order: idx });
              t.order = idx;
            }
          });
          try { await batch.commit(); } catch(e) { console.warn(e); }
        }

        // ③ まず「未完了」「完了」で分け、各グループ内は order でソート
        const active = todos.filter(t => !t.done).sort((a,b)=>{
          const ao = (a.order ?? a._fallbackIndex);
          const bo = (b.order ?? b._fallbackIndex);
          return ao - bo;
        });
        const completed = todos.filter(t => t.done).sort((a,b)=>{
          const ao = (a.order ?? a._fallbackIndex);
          const bo = (b.order ?? b._fallbackIndex);
          return ao - bo;
        });

        latestTodos = [...active, ...completed];

        // ④ 描画（未完了→完了の順）
        list.innerHTML = "";
        latestTodos.forEach((t) => {
          const li = document.createElement("li");
          li.className = "todo-item";
          li.dataset.id = t.id;
          li.dataset.done = String(t.done);

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = t.done;

          const textWrap = document.createElement("div");
          textWrap.className = "text" + (t.done ? " done" : "");
          textWrap.textContent = t.text;

          const author = document.createElement("span");
          author.className = "author";
          author.textContent = t.authorName;

          const delBtn = document.createElement("button");
          delBtn.textContent = "削除";

          checkbox.addEventListener("change", async () => {
            await setDoneWithOrder(t, checkbox.checked);
          });

          delBtn.addEventListener("click", () => {
            deleteDoc(doc(todosCol, t.id));
          });

          // 行タップでもチェック切替（入力/ボタン/並び替え中は除外）
          li.addEventListener("click", async (ev) => {
            if (isSorting) return;
            const tag = ev.target.tagName?.toLowerCase();
            if (tag === "input" || tag === "button") return;

            checkbox.checked = !checkbox.checked;
            await setDoneWithOrder(t, checkbox.checked);
          });

          li.appendChild(checkbox);

          const textRow = document.createElement("div");
          textRow.style.display = "flex";
          textRow.style.alignItems = "center";
          textRow.style.gap = ".5rem";
          textRow.style.flex = "1";
          textRow.appendChild(textWrap);
          textRow.appendChild(author);

          li.appendChild(textRow);
          li.appendChild(delBtn);
          list.appendChild(li);
        });

        // ⑤ Sortable再初期化（即ドラッグ）
        if (sortable) sortable.destroy();
        isSorting = false;

        sortable = new Sortable(list, {
          animation: 150,
          delay: 0,
          delayOnTouchOnly: false,
          touchStartThreshold: 3,
          ghostClass: "sortable-ghost",

          onStart: () => { isSorting = true; },

          onEnd: async () => {
            const children = Array.from(list.children);
            const activeIds = children.filter(li => li.dataset.done === "false")
                                      .map(li => li.dataset.id);
            const doneIds = children.filter(li => li.dataset.done === "true")
                                    .map(li => li.dataset.id);

            const batch = writeBatch(db);
            activeIds.forEach((id, idx) => {
              batch.update(doc(todosCol, id), { order: idx });
            });
            doneIds.forEach((id, idx) => {
              batch.update(doc(todosCol, id), { order: idx });
            });

            try { await batch.commit(); }
            catch(e){
              console.error(e);
              alert("並び替え保存に失敗: " + e.message);
            } finally {
              setTimeout(() => { isSorting = false; }, 0);
            }
          }
        });
      });
    });

    // 追加（未完了の末尾に order で追加）
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const text = input.value.trim();
      if (!text || !currentUser) return;

      try {
        const nextOrder = nextOrderFor(false);
        await addDoc(todosCol, {
          text,
          done: false,
          createdAt: serverTimestamp(),
          authorUid: currentUser.uid,
          authorName: displayName || "unknown",
          order: nextOrder
        });
        input.value = '';
        input.focus();
      } catch (e) {
        console.error(e);
        alert('追加に失敗しました: ' + e.message);
      }
    });
  </script>
</body>
</html>
